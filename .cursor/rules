# .cursor/rules - Kanban Project Development Rules

# ==========================================
# REACT 19 COMPONENT STANDARDS
# ==========================================

# All React components must follow this exact pattern:
# export const ComponentName: FC<IComponentName> = ({ prop1, prop2, ...props }) => {
#   return (
#     // JSX here
#   );
# };

react_component_pattern:
  - All functional components MUST use FC type from React
  - All components MUST have interface starting with "I" prefix (e.g., IKanbanBoard)
  - All components MUST use destructured props in parameters
  - All components MUST use const assertion with arrow function
  - Export MUST be at component declaration level
  - NO default exports for components (use named exports only)
  - Example: export const KanbanBoard: FC<IKanbanBoard> = ({ columns, useOwnStyles, onCardMove }) => {}

# ==========================================
# STYLING SYSTEM RULES
# ==========================================

styling_architecture:
  - ALWAYS include useOwnStyles prop in component interfaces
  - useOwnStyles: boolean - when true, component uses external styles; when false, uses internal styles
  - Internal styles should be defined as CSS modules or styled-components
  - External styles should be passed via className prop
  - Style prop pattern: useOwnStyles?: boolean; className?: string;
  - Conditional styling: style={useOwnStyles ? {} : internalStyles}

# ==========================================
# PERFORMANCE OPTIMIZATION RULES
# ==========================================

performance_rules:
  - ALWAYS wrap expensive computations in useMemo
  - ALWAYS wrap callback functions in useCallback
  - ALWAYS use React.memo for components that receive complex props
  - ALWAYS use useRef for DOM references and mutable values
  - NEVER create objects/arrays in render (move to useMemo)
  - NEVER create inline functions in JSX (use useCallback)
  - Use React.lazy for code splitting when component > 100 lines
  - Implement virtualization for lists > 100 items

# ==========================================
# CLEAN CODE PRINCIPLES
# ==========================================

clean_code_rules:
  - Function names MUST be descriptive verbs (handleCardDrag, updateColumnOrder)
  - Variable names MUST be descriptive nouns (draggedCard, targetColumn)
  - Boolean variables MUST start with is/has/can/should (isDragging, hasPermission)
  - Constants MUST be UPPER_SNAKE_CASE
  - Interfaces MUST start with "I" prefix
  - Maximum function length: 20 lines
  - Maximum component length: 150 lines (split if larger)
  - ALWAYS extract complex logic to custom hooks
  - ALWAYS use early returns to avoid deep nesting
  - ALWAYS add TypeScript types - NO any types allowed

# ==========================================
# KANBAN-SPECIFIC RULES
# ==========================================

kanban_rules:
  - All drag operations MUST use custom hooks (useDrag, useDrop, useCursor)
  - Kanban state MUST be managed with useReducer for complex state updates
  - Card movements MUST be optimistic with rollback on error
  - ALWAYS implement keyboard navigation (arrow keys, enter, escape)
  - ALWAYS implement accessibility (ARIA labels, role attributes)
  - Column reordering MUST be supported
  - Card filtering/searching MUST be debounced (300ms minimum)

# ==========================================
# HOOK CREATION RULES
# ==========================================

custom_hooks_rules:
  - Hook names MUST start with "use" prefix
  - Hooks MUST return object with descriptive properties
  - Hooks MUST include cleanup in useEffect when needed
  - Export hook interface: export interface IUseHookNameReturn
  - Hook pattern: export const useHookName = (options: IUseHookNameOptions): IUseHookNameReturn => {}
  - ALWAYS memoize returned functions with useCallback
  - ALWAYS memoize returned objects with useMemo when containing functions

# ==========================================
# FILE STRUCTURE RULES
# ==========================================

file_structure:
  - Components: src/components/ComponentName/ComponentName.tsx
  - Hooks: src/hooks/useHookName.ts
  - Types: src/types/ComponentName.types.ts (when interface > 5 properties)
  - Styles: src/components/ComponentName/ComponentName.module.css
  - Tests: src/components/ComponentName/ComponentName.test.tsx
  - Stories: src/components/ComponentName/ComponentName.stories.tsx

# ==========================================
# IMPORT/EXPORT RULES
# ==========================================

import_export_rules:
  - React imports: import { FC, useState, useCallback, useMemo } from 'react'
  - ALWAYS group imports: React, external libs, internal components, types, styles
  - ALWAYS use absolute imports for src/ directory
  - Export pattern: export { ComponentName, type IComponentName }
  - NO default exports except for lazy-loaded components
  - Barrel exports in index.ts files: export * from './ComponentName'

# ==========================================
# ERROR HANDLING RULES
# ==========================================

error_handling:
  - ALWAYS use Error Boundaries for component trees
  - ALWAYS handle async operations with try-catch
  - ALWAYS provide fallback UI for failed states
  - ALWAYS log errors with context information
  - Use React Query/SWR for data fetching with built-in error states

# ==========================================
# TESTING REQUIREMENTS
# ==========================================

testing_rules:
  - EVERY component MUST have unit tests
  - EVERY custom hook MUST have unit tests
  - Test user interactions with @testing-library/user-event
  - Test accessibility with @testing-library/jest-dom
  - Minimum 80% code coverage required
  - Integration tests for drag-and-drop functionality

# ==========================================
# TYPESCRIPT STRICTNESS
# ==========================================

typescript_rules:
  - strict: true in tsconfig.json
  - noImplicitAny: true
  - strictNullChecks: true
  - NEVER use any type
  - ALWAYS define return types for functions
  - ALWAYS use const assertions for objects/arrays
  - Use utility types: Partial<T>, Required<T>, Pick<T, K>, Omit<T, K>

# ==========================================
# ACCESSIBILITY REQUIREMENTS
# ==========================================

accessibility_rules:
  - ALWAYS include proper ARIA labels
  - ALWAYS support keyboard navigation
  - ALWAYS maintain focus management
  - Color contrast ratio minimum 4.5:1
  - ALWAYS include alt text for images
  - ALWAYS use semantic HTML elements
  - Screen reader testing required for drag-drop

# ==========================================
# EXAMPLE IMPLEMENTATIONS
# ==========================================

# CORRECT Component Example:
# export const KanbanBoard: FC<IKanbanBoard> = ({ columns, useOwnStyles = false, onCardMove }) => {
#   const memoizedColumns = useMemo(() => columns.filter(col => col.isVisible), [columns]);
#   
#   const handleCardMove = useCallback((cardId: string, targetColumnId: string) => {
#     onCardMove?.(cardId, targetColumnId);
#   }, [onCardMove]);
#
#   return (
#     <div className={useOwnStyles ? undefined : styles.kanbanBoard}>
#       {memoizedColumns.map(column => (
#         <KanbanColumn key={column.id} column={column} onCardMove={handleCardMove} />
#       ))}
#     </div>
#   );
# };

# CORRECT Hook Example:
# export const useDragDrop = (options: IUseDragDropOptions): IUseDragDropReturn => {
#   const [dragState, setDragState] = useState<IDragState>(initialState);
#   
#   const handleDragStart = useCallback((item: DragItem) => {
#     setDragState(prev => ({ ...prev, isDragging: true, draggedItem: item }));
#   }, []);
#
#   const resetDrag = useCallback(() => {
#     setDragState(initialState);
#   }, []);
#
#   return useMemo(() => ({
#     dragState,
#     handleDragStart,
#     resetDrag
#   }), [dragState, handleDragStart, resetDrag]);
# };